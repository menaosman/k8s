trigger:
  branches: { include: [ main ] }
  paths:    { include: [ k8s/*, azure-pipelines-cd.yml ] }

pr: none

variables:
  APP_NAME: 'myapp'
  DOCKER_IMAGE: 'dockerhubuser/repo'   # e.g., menaosman/github-action-app
  IMAGE_TAG: 'latest'                  # or a build/tag variable
  AWS_REGION: 'YOUR_AWS_REGION'        # e.g., eu-central-1, me-central-1, af-south-1
  EKS_CLUSTER_NAME: 'YOUR_EKS_CLUSTER'
  K8S_NAMESPACE: 'prod'
  SERVICE_PORT: '80'

  # Optional TLS via ACM (set as pipeline variable or here)
  ACM_CERT_ARN: ''

stages:
- stage: Deploy
  displayName: Deploy to EKS via ALB Ingress
  jobs:
  - job: Deploy
    displayName: Apply K8s manifests
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self

    - script: |
        set -euxo pipefail
        sudo apt-get update -y
        sudo apt-get install -y curl unzip jq
        curl -sSL https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
        unzip -q awscliv2.zip
        sudo ./aws/install
        curl -LO "https://dl.k8s.io/release/$(curl -Ls https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
      displayName: Install AWS CLI & kubectl

    - script: |
        set -euxo pipefail
        if [ -n "${AWS_ROLE_ARN:-}" ]; then
          CREDS=$(aws sts assume-role --role-arn "$AWS_ROLE_ARN" --role-session-name "azdo-eks-$(date +%s)")
          export AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r .Credentials.AccessKeyId)
          export AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r .Credentials.SecretAccessKey)
          export AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r .Credentials.SessionToken)
        fi
        aws sts get-caller-identity
        aws eks update-kubeconfig --name "$(EKS_CLUSTER_NAME)" --region "$(AWS_REGION)"
        kubectl get nodes
      env:
        AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_DEFAULT_REGION: $(AWS_REGION)
        AWS_REGION: $(AWS_REGION)
        AWS_ROLE_ARN: $(AWS_ROLE_ARN)
      displayName: Auth to AWS & EKS

    - script: |
        set -euxo pipefail
        kubectl create namespace "$(K8S_NAMESPACE)" --dry-run=client -o yaml | kubectl apply -f -

        IMG="$(DOCKER_IMAGE):$(IMAGE_TAG)"
        echo "Deploying image: $IMG"
        kubectl -n "$(K8S_NAMESPACE)" apply -f k8s/
        kubectl -n "$(K8S_NAMESPACE)" set image deployment/$(APP_NAME) $(APP_NAME)="$IMG" --record

        if [ -n "${ACM_CERT_ARN:-}" ]; then
          kubectl -n "$(K8S_NAMESPACE)" annotate ingress/$(APP_NAME)             alb.ingress.kubernetes.io/certificate-arn="${ACM_CERT_ARN}"             alb.ingress.kubernetes.io/listen-ports='[{"HTTP":80},{"HTTPS":443}]'             alb.ingress.kubernetes.io/ssl-redirect='443' --overwrite
        fi

        kubectl -n "$(K8S_NAMESPACE)" rollout status deployment/$(APP_NAME) --timeout=5m
      displayName: Apply manifests, set image, add TLS (optional)

    - script: |
        set -euxo pipefail
        for i in {1..40}; do
          IHOST=$(kubectl -n "$(K8S_NAMESPACE)" get ingress $(APP_NAME) -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
          if [ -n "$IHOST" ]; then break; fi
          echo "Waiting for Ingress (ALB) hostname ($i/40)..."
          sleep 15
        done

        if [ -n "$IHOST" ]; then
          if [ -n "${ACM_CERT_ARN:-}" ]; then
            APP_URL="https://$IHOST"
          else
            APP_URL="http://$IHOST"
          fi
        else
          HOST=$(kubectl -n "$(K8S_NAMESPACE)" get svc $(APP_NAME) -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
          IP=$(kubectl -n "$(K8S_NAMESPACE)" get svc $(APP_NAME) -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
          URL=${HOST:-$IP}
          if [ -z "$URL" ] ; then
            echo "No external address found for Ingress or Service."
            kubectl -n "$(K8S_NAMESPACE)" get ingress $(APP_NAME) -o wide || true
            kubectl -n "$(K8S_NAMESPACE)" get svc $(APP_NAME) -o wide || true
            exit 1
          fi
          APP_URL="http://$URL:$(SERVICE_PORT)"
        fi

        echo "App URL: $APP_URL"
        echo "##vso[task.setvariable variable=APP_URL;isOutput=true]$APP_URL"

        cat > summary.md <<EOF
        ### âœ… Deployment Succeeded

        **Namespace:** \`$(K8S_NAMESPACE)\`  
        **Ingress/Service:** \`$(APP_NAME)\`  

        **Open your app:** [${APP_URL}](${APP_URL})

        \`\`\`bash
        kubectl -n $(K8S_NAMESPACE) get ingress $(APP_NAME) -o wide
        kubectl -n $(K8S_NAMESPACE) get svc $(APP_NAME) -o wide
        \`\`\`
        EOF
        echo "##vso[task.uploadsummary]summary.md"
      name: PublishUrl
      displayName: Get ALB hostname & publish summary
